version: '3'

tasks:

  # `task test` is equivalent to `task test:sequential`
  # intentionally not using a desc:, instead the sequential: task has the description and indicates it is the default task
  default:
    cmds:
      - task: sequential
    silent: true

  # === Testing ===
  test:_check:
    desc: Internal task to check for misplaced config.json in apps directory
    internal: true
    cmds:
      - cmd: |
          if [ -f ~/.config/appimage-updater/apps/config.json ]; then
            echo "ERROR: Found config.json in apps/ directory!"
            echo "This file should be at ~/.config/appimage-updater/config.json, not in apps/"
            echo "A test is writing to the real config directory instead of using temp directories."
            echo "Please remove it with: rm ~/.config/appimage-updater/apps/config.json"
            exit 1
          fi
        silent: true

  sequential:
    desc: Run tests with pytest (sequential) with coverage (default test task)
    summary: Runs all core tests (unit, functional, integration, e2e) with coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} --cov=src/{{.APP_NAME}} --cov-report=term-missing --cov-report=html {{.TEST_CORE}} {{.CLI_ARGS}}

  parallel:
    desc: Run tests with pytest (parallel) with coverage
    summary: Runs all core tests (unit, functional, integration, e2e) with coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} -n auto --cov=src/{{.APP_NAME}} --cov-report=term-missing --cov-report=html {{.TEST_CORE}} {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"


  unit:
    desc: Run unit tests only with coverage
    summary: Runs tests/unit/ with coverage, hiding 100% covered files
    cmds:
      - bash -c 'set -o pipefail; uv run pytest --timeout {{.TEST_TIMEOUT}} --cov=src/{{.APP_NAME}} --cov-report=term:skip-covered --cov-report=html tests/unit/ {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"'

  functional:
    desc: Run functional tests only with coverage
    summary: Runs tests/functional/ with coverage, hiding 100% covered files
    cmds:
      - bash -c 'set -o pipefail; uv run pytest --timeout {{.TEST_TIMEOUT}} --cov=src/{{.APP_NAME}} --cov-report=term:skip-covered --cov-report=html tests/functional/ {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"'

  integration:
    desc: Run integration tests only with coverage
    summary: Runs tests/integration/ with coverage, hiding 100% covered files
    cmds:
      - bash -c 'set -o pipefail; uv run pytest --timeout {{.TEST_TIMEOUT}} --cov=src/{{.APP_NAME}} --cov-report=term:skip-covered --cov-report=html tests/integration/ {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"'

  e2e:
    desc: Run end-to-end tests to validate core functionality (serially for test isolation) without coverage
    summary: Runs tests/e2e/ with verbose output, no coverage
    cmds:
      - bash -c 'set -o pipefail; uv run pytest --timeout {{.TEST_TIMEOUT}} tests/e2e/ -v --tb=short --color=yes 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"'
      - task: _check

  test:pattern-matching:
    desc: Test pattern matching functionality specifically - summary coverage reporting
    cmds:
      - bash -c 'set -o pipefail; uv run pytest --timeout {{.TEST_TIMEOUT}} tests/e2e/test_pattern_matching.py -v 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"'
      - task: _check
      - bash -c 'set -o pipefail; uv run pytest --timeout {{.TEST_TIMEOUT}} tests/unit/test_intelligent_pattern_generation.py -v 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"'
      - task: _check

  test:regression:
    desc: Run regression tests to validate fixed issues (uses network) - full coverage reporting
    cmds:
    # do not use timeout here as it will cause the test to fail
      - uv run pytest tests/regression/ -v --tb=short --color=yes
      - task: _check
      - echo "âœ… Regression tests passed - fixed issues remain resolved!"
    silent: true

  all:
    desc: Run all tests against all Python versions without coverage
    summary: Tests against multiple Python versions using uv.  This rebuilds .venv for each Python version, restoring to the .python-version at the end.
    cmds:
      - echo "ðŸ Running tests against all Python versions..."
      - for:
          var: PYTHON_VERSIONS
          split: ' '
        cmd: |
          echo "ðŸ“‹ Testing with Python {{.ITEM}}"
          bash -c 'set -o pipefail; uv run --python {{.ITEM}} pytest --timeout {{.TEST_TIMEOUT}} {{.TEST_CORE}} --tb=short --color=yes 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"'
      - task: env:sync
      - echo "âœ… All Python versions tested successfully!"
    silent: true

  coverage:
    desc: Run all tests with detailed coverage reporting (XML, HTML, terminal)
    summary: Generates comprehensive coverage reports in multiple formats
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} {{.TEST_CORE}} --cov=src/{{.APP_NAME}} --cov-report=xml --cov-report=term-missing --cov-report=html:htmlcov
      - task: _check
      - echo "ðŸ“Š Coverage report saved to htmlcov/index.html"
    silent: true
