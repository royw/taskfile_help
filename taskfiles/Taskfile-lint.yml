version: '3'

tasks:

  default:
    cmds:
      - task: src
    silent: true

  # === Internal Helpers ===

  _check_tmp:
    desc: Internal task to check for hardcoded /tmp/ paths
    internal: true
    cmds:
      - cmd: |
          echo "Checking for hardcoded /tmp/ paths..."
          TMP_FOUND=0
          TMP_COUNT=0
          SEARCH_PATH="{{.SEARCH_PATH}}"
          
          # Search for "/tmp/" in all Python files and count occurrences
          # grep returns exit code 1 if no matches found, so we use || true to prevent script failure
          TMP_RESULTS=$(grep -rn --include="*.py" '"/tmp/' $SEARCH_PATH 2>/dev/null || true)
          if [ -n "$TMP_RESULTS" ]; then
            echo "$TMP_RESULTS"
            TMP_COUNT=$(echo "$TMP_RESULTS" | wc -l)
            echo "FAIL Hardcoded /tmp/ paths found - use tmp_path fixture instead"
            TMP_FOUND=1
          fi
          
          if [ $TMP_FOUND -eq 0 ]; then
            echo "PASS No hardcoded /tmp/ paths found"
            exit 0
          else
            echo "FAIL Lint failed - $TMP_COUNT hardcoded /tmp/ paths found"
            echo "Fix: Replace hardcoded /tmp/ paths with pytest's tmp_path fixture"
            exit 1
          fi
        silent: true

  # === Linting ===

  src:
    desc: Run all linting tasks on src/ (default lint task)
    cmds:
      - task: fix
      - task: ruff
      - task: mypy
      - task: markdown
      - task: deadcode
      - task: packages
      - task: _check_tmp
        vars:
          SEARCH_PATH: "{{.SRC}}"

  tests:
    desc: Run linting on core tests with ruff and check for hardcoded /tmp/ paths
    cmds:
      - uv run ruff check --fix --select I {{.CLI_ARGS | default .TESTS_CORE}}
      - uv run mypy {{.CLI_ARGS | default .TESTS_CORE}}
      - task: _check_tmp
        vars:
          SEARCH_PATH: "{{.TESTS}}"

  ruff:
    desc: Run linting with ruff
    cmds:
      - uv run ruff check {{.CLI_ARGS | default .SRC}}

  mypy:
    desc: Run type checking with mypy
    cmds:
      - uv run mypy {{.CLI_ARGS | default .SRC}}

  fix:
    desc: Automatically fix linting issues in src/ with ruff
    cmds:
      - uv run ruff check --fix --select I {{.CLI_ARGS | default .SRC}}

  fix:tests:
    desc: Automatically fix linting issues in tests/ with ruff
    cmds:
      - uv run ruff check --fix --select I {{.CLI_ARGS | default .TESTS}}

  markdown:
    desc: Lint markdown files with pymarkdownlnt
    cmds:
      - cmd: |
          if ! command -v pymarkdownlnt &> /dev/null; then
            uv tool install pymarkdownlnt
          fi
        silent: true
      - uv run pymarkdownlnt --config .pymarkdown.json scan {{.CLI_ARGS | default "*.md docs/*.md"}} || true

  deadcode:
    desc: Find dead (unreachable/unused) code with deadcode (config in pyproject.toml)
    cmds:
      - cmd: echo "Checking deadcode..."
        silent: true
      - uv run deadcode {{.CLI_ARGS | default .SRC}}
    silent: true

  packages:
    desc: Verify that __init__.py files only contain docstrings (no code)
    cmds:
      - cmd: |
          echo "Checking __init__.py files for code violations..."
          VIOLATIONS=0
          
          # Find all __init__.py files in src/
          while IFS= read -r file; do
            # Skip if file doesn't exist or is empty
            if [ ! -f "$file" ] || [ ! -s "$file" ]; then
              continue
            fi
            
            # Use Python to check if file contains only docstrings and comments
            if ! python3 << PYTHON_SCRIPT
          import ast
          import sys
          
          try:
              with open('$file', 'r') as f:
                  content = f.read()
              
              # Parse the file
              tree = ast.parse(content)
              
              # Check if there are any statements other than docstrings
              has_code = False
              for node in tree.body:
                  # Allow module docstrings (Expr node with a Constant value)
                  if isinstance(node, ast.Expr) and isinstance(node.value, ast.Constant):
                      continue
                  # Everything else is considered code
                  has_code = True
                  break
              
              if has_code:
                  print(f"FAIL: $file contains code beyond docstrings", file=sys.stderr)
                  sys.exit(1)
              
              sys.exit(0)
          except SyntaxError as e:
              print(f"ERROR: $file has syntax error: {e}", file=sys.stderr)
              sys.exit(1)
          PYTHON_SCRIPT
            then
              VIOLATIONS=$((VIOLATIONS + 1))
            fi
          done < <(find src -name "__init__.py" -type f)
          
          if [ $VIOLATIONS -eq 0 ]; then
            echo "PASS All __init__.py files are clean (docstrings only)"
          else
            echo "FAIL Found $VIOLATIONS __init__.py file(s) with code violations"
            exit 1
          fi
        silent: true

  duplication:
    desc: Check for duplicate code using pylint
    cmds:
      - cmd: echo "Checking for code duplication..."
        silent: true
      - uv run pylint --disable=all --enable=duplicate-code {{.CLI_ARGS | default .SRC}}

  # === Help ===
  help:
    desc: Show available tasks from this Taskfile
    cmd: taskfile-help lint
    silent: true
