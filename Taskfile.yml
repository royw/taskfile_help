version: '3'

includes:
  git:
    taskfile: ./taskfiles/Taskfile-git.yml
    dir: .
  version:
    taskfile: ./taskfiles/Taskfile-version.yml
    dir: .
  docs:
    taskfile: ./taskfiles/Taskfile-docs.yml
    dir: .
  metrics:
    taskfile: ./taskfiles/Taskfile-metrics.yml
    dir: .
  lint:
    taskfile: ./taskfiles/Taskfile-lint.yml
    dir: .
  test:
    taskfile: ./taskfiles/Taskfile-test.yml
    dir: .
  format:
    taskfile: ./taskfiles/Taskfile-format.yml
    dir: .
  release:
    taskfile: ./taskfiles/Taskfile-release.yml
    dir: .
  env:
    taskfile: ./taskfiles/Taskfile-env.yml
    dir: .

vars:
  # Application name derived from pyproject.toml (hyphens replaced with underscores for Python module name)
  APP_NAME:
    sh: python3 -c "import tomllib; f = open('pyproject.toml', 'rb'); data = tomllib.load(f); f.close(); print(data['project']['name'].replace('-', '_'))"
  
  # Source code directory
  SRC: src/
  
  # Root tests directory
  TESTS: tests/
  
  # Test directories to include in normal test runs (excludes performance, benchmarks, etc.)
  # Include directories here even if they don't exist yet (e.g., tests/integration/)
  POSSIBLE_TEST_CORES: tests/unit/ tests/functional/ tests/integration/ tests/e2e/
  
  # Subset of POSSIBLE_TEST_CORES that actually exist on disk (auto-detected)
  TESTS_CORE:
    sh: |
      possible="{{.POSSIBLE_TEST_CORES}}"
      existing=""
      for dir in $possible; do
        if [ -d "$dir" ]; then
          existing="$existing$dir "
        fi
      done
      echo "$existing" | sed 's/[[:space:]]*$//'
  
  # Test timeout in seconds
  TEST_TIMEOUT: 30
  
  # All Python versions from .python-versions file (space-separated)
  PYTHON_VERSIONS:
    sh: cat .python-versions | grep -v '^$' | tr '\n' ' ' | sed 's/[[:space:]]*$//'
  
  # Current Python version from .python-version file
  PYTHON_VERSION:
    sh: cat .python-version | head -n1

tasks:
  default:
    cmds:
     - task --list --sort none
    silent: true

  # === Quality Checks ===
  check:
    desc: Run all code quality checks including end-to-end tests
    cmds:
      - task: format
      - task: lint
      - task: metrics:complexity
      - task: test

  # === Build ===
  build:
    desc: Build distribution packages
    deps:
      - env:clean
    cmds:
      - cmd: echo "üèóÔ∏è  Building distribution packages..."
        silent: true
      - uv build {{.CLI_ARGS}}
      - cmd: echo "‚úÖ Build complete! Packages created in dist/"
        silent: true
      - ls -la dist/

  make:
    desc: Complete build pipeline - run all checks, build, docs, and show version
    cmds:
      - cmd: echo "üöÄ Starting build pipeline..."
        silent: true
      - task: check
      - task: build
      - task: docs:build
      - task: version:current
      - cmd: echo "‚úÖ Build pipeline completed successfully! Ready to push to GitHub üéâ"
        silent: true

  # === CI/CD Pipeline ===
  ci:
    desc: Run GitHub CI build locally using scripts/ci-local.sh.  This is the same pipeline that runs on GitHub Actions.
    cmds:
      - bash scripts/ci-local.sh

    # === Deploy ===
  deploy:local:
    desc: Install the built package locally using pipx
    deps:
      - build
    cmds:
      - cmd: echo "üöÄ Installing locally with pipx..."
        silent: true
      - pipx install --force dist/*.whl
      - cmd: echo "‚úÖ Successfully deployed  {{.APP_NAME}} v$(task version) locally!"
        silent: true

  # === Running ===
  run:
    desc: Run the application
    cmds:
      - uv run python -m {{.APP_NAME}} {{.CLI_ARGS}}


  # === Help ===
  help:
    desc: Show available tasks from this Taskfile
    cmd: taskfile-help
    silent: true  # Suppress task command echo
    
  help:all:
    desc: Show available tasks from all Taskfiles
    cmd: taskfile-help all
    silent: true  # Suppress task command echo
